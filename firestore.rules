rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions for user authentication and authorization
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    function isArtist() {
      return isAuthenticated() && 
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.userType == 'artist';
    }
    
    function isCustomer() {
      return isAuthenticated() && 
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.userType == 'customer';
    }
    
    function isParticipantInBooking(booking) {
      return booking.customerId == request.auth.uid || booking.artistId == request.auth.uid;
    }
    
    function isValidUserType(userType) {
      return userType in ['customer', 'artist'];
    }
    
    function isValidEmail(email) {
      return email is string && email.matches('.*@.*\\..*');
    }
    
    // Users collection rules
    match /users/{userId} {
      // Users can read their own profile and public profiles of artists
      allow read: if isOwner(userId) || 
                     (isAuthenticated() && get(/databases/$(database)/documents/users/$(userId)).data.userType == 'artist');
      
      // Users can only create/update their own profile with valid data
      allow create, update: if isOwner(userId) && 
                               validateUserData(resource.data) &&
                               isValidUserType(resource.data.userType) &&
                               isValidEmail(resource.data.email);
      
      // Users cannot delete their profiles (soft delete should be used instead)
      allow delete: if false;
      
      function validateUserData(data) {
        return data.keys().hasAll(['uid', 'email', 'userType', 'createdAt', 'updatedAt']) &&
               data.uid is string &&
               data.email is string &&
               data.userType is string &&
               data.createdAt is timestamp &&
               data.updatedAt is timestamp &&
               (data.userType == 'customer' || validateArtistData(data));
      }
      
      function validateArtistData(data) {
        return data.userType == 'artist' &&
               data.keys().hasAny(['artistInfo']) &&
               (data.artistInfo == null || 
                (data.artistInfo.keys().hasAny(['specialties', 'bio', 'pricing', 'rating', 'reviewCount']) &&
                 (data.artistInfo.specialties == null || data.artistInfo.specialties is list) &&
                 (data.artistInfo.rating == null || (data.artistInfo.rating is number && data.artistInfo.rating >= 0 && data.artistInfo.rating <= 5)) &&
                 (data.artistInfo.reviewCount == null || (data.artistInfo.reviewCount is number && data.artistInfo.reviewCount >= 0))));
      }
    }
    
    // Portfolio items collection rules
    match /portfolioItems/{itemId} {
      // Anyone can read portfolio items (public visibility)
      allow read: if isAuthenticated();
      
      // Only the artist owner can create/update/delete their portfolio items
      allow create, update, delete: if isAuthenticated() && 
                                       isOwner(resource.data.artistId) &&
                                       isArtist();
      
      // Validate portfolio item data
      allow create, update: if validatePortfolioData(resource.data);
      
      function validatePortfolioData(data) {
        return data.keys().hasAll(['artistId', 'imageUrl', 'createdAt', 'updatedAt']) &&
               data.artistId is string &&
               data.imageUrl is string &&
               data.createdAt is timestamp &&
               data.updatedAt is timestamp &&
               (data.tags == null || data.tags is list) &&
               (data.aiAnalysis == null || data.aiAnalysis is map);
      }
    }
    
    // Inquiries collection rules
    match /inquiries/{inquiryId} {
      // Only participants (customer and artist) can read inquiries
      allow read: if isAuthenticated() && 
                     (isOwner(resource.data.customerId) || isOwner(resource.data.artistId));
      
      // Only customers can create inquiries
      allow create: if isAuthenticated() && 
                       isCustomer() && 
                       isOwner(resource.data.customerId) &&
                       validateInquiryData(resource.data);
      
      // Only the artist can update inquiry status
      allow update: if isAuthenticated() && 
                       isOwner(resource.data.artistId) && 
                       isArtist();
      
      // No one can delete inquiries
      allow delete: if false;
      
      function validateInquiryData(data) {
        return data.keys().hasAll(['customerId', 'artistId', 'status', 'createdAt']) &&
               data.customerId is string &&
               data.artistId is string &&
               data.status in ['pending', 'responded', 'closed'] &&
               data.createdAt is timestamp;
      }
    }
    
    // Booking requests collection rules
    match /bookingRequests/{bookingId} {
      // Only participants (customer and artist) can read booking requests
      allow read: if isAuthenticated() && 
                     (isOwner(resource.data.customerId) || isOwner(resource.data.artistId));
      
      // Only customers can create booking requests
      allow create: if isAuthenticated() && 
                       isCustomer() && 
                       isOwner(resource.data.customerId) &&
                       validateBookingRequestData(resource.data);
      
      // Only participants can update booking requests
      allow update: if isAuthenticated() && 
                       (isOwner(resource.data.customerId) || isOwner(resource.data.artistId)) &&
                       validateBookingStatusUpdate(resource.data, request.resource.data);
      
      // No one can delete booking requests
      allow delete: if false;
      
      function validateBookingRequestData(data) {
        return data.keys().hasAll(['customerId', 'artistId', 'status', 'createdAt', 'updatedAt', 'preferredDate']) &&
               data.customerId is string &&
               data.artistId is string &&
               data.status == 'pending' &&
               data.createdAt is timestamp &&
               data.updatedAt is timestamp &&
               data.preferredDate is timestamp &&
               data.preferredDate > request.time;
      }
      
      function validateBookingStatusUpdate(oldData, newData) {
        let validTransitions = {
          'pending': ['accepted', 'declined', 'negotiating', 'cancelled'],
          'accepted': ['confirmed', 'cancelled'],
          'declined': [],
          'negotiating': ['accepted', 'declined', 'cancelled'],
          'confirmed': ['completed', 'cancelled'],
          'completed': [],
          'cancelled': []
        };
        
        return newData.status in validTransitions[oldData.status];
      }
    }
    
    // Counter offer details collection rules
    match /counterOfferDetails/{detailId} {
      // Only participants can read counter offer details
      allow read: if isAuthenticated() && 
                     exists(/databases/$(database)/documents/bookingRequests/$(resource.data.bookingId)) &&
                     isParticipantInBooking(get(/databases/$(database)/documents/bookingRequests/$(resource.data.bookingId)).data);
      
      // Only artists can create counter offer details
      allow create: if isAuthenticated() && 
                       isArtist() &&
                       exists(/databases/$(database)/documents/bookingRequests/$(resource.data.bookingId));
      
      // No updates or deletes allowed
      allow update, delete: if false;
    }
    
    // Confirmed bookings collection rules
    match /confirmedBookings/{confirmedBookingId} {
      // Only participants can read confirmed bookings
      allow read: if isAuthenticated() && 
                     (isOwner(resource.data.customerId) || isOwner(resource.data.artistId));
      
      // Only the booking service can create confirmed bookings (through server-side logic)
      allow create: if isAuthenticated() && 
                       isArtist() && 
                       isOwner(resource.data.artistId) &&
                       validateConfirmedBookingData(resource.data);
      
      // Only participants can update status to completed
      allow update: if isAuthenticated() && 
                       (isOwner(resource.data.customerId) || isOwner(resource.data.artistId)) &&
                       (resource.data.status == 'scheduled' && request.resource.data.status == 'completed');
      
      // No deletes allowed
      allow delete: if false;
      
      function validateConfirmedBookingData(data) {
        return data.keys().hasAll(['bookingRequestId', 'customerId', 'artistId', 'appointmentDate', 'status', 'createdAt']) &&
               data.bookingRequestId is string &&
               data.customerId is string &&
               data.artistId is string &&
               data.appointmentDate is timestamp &&
               data.status == 'scheduled' &&
               data.createdAt is timestamp;
      }
    }
    
    // Reviews collection rules
    match /reviews/{reviewId} {
      // Anyone can read reviews (public visibility for transparency)
      allow read: if isAuthenticated();
      
      // Only customers can create reviews for bookings they participated in
      allow create: if isAuthenticated() && 
                       isCustomer() && 
                       isOwner(resource.data.customerId) &&
                       validateReviewData(resource.data) &&
                       exists(/databases/$(database)/documents/confirmedBookings/$(resource.data.bookingId)) &&
                       get(/databases/$(database)/documents/confirmedBookings/$(resource.data.bookingId)).data.customerId == request.auth.uid &&
                       get(/databases/$(database)/documents/confirmedBookings/$(resource.data.bookingId)).data.status == 'completed';
      
      // Customers can update their own reviews within 30 days
      allow update: if isAuthenticated() && 
                       isOwner(resource.data.customerId) &&
                       resource.data.createdAt > timestamp.date(2024, 1, 1) && // Ensure createdAt exists
                       (request.time - resource.data.createdAt) < duration.value(30, 'd');
      
      // No one can delete reviews (for transparency)
      allow delete: if false;
      
      function validateReviewData(data) {
        return data.keys().hasAll(['customerId', 'artistId', 'bookingId', 'rating', 'createdAt']) &&
               data.customerId is string &&
               data.artistId is string &&
               data.bookingId is string &&
               data.rating is number &&
               data.rating >= 1 && data.rating <= 5 &&
               data.createdAt is timestamp &&
               (data.comment == null || data.comment is string);
      }
    }
    
    // Artist schedules collection rules
    match /artistSchedules/{scheduleId} {
      // Anyone can read artist schedules (for booking availability)
      allow read: if isAuthenticated();
      
      // Only the artist owner can create/update their schedules
      allow create, update: if isAuthenticated() && 
                               isArtist() && 
                               isOwner(resource.data.artistId);
      
      // Artists can delete their own schedules
      allow delete: if isAuthenticated() && 
                       isArtist() && 
                       isOwner(resource.data.artistId);
    }
    
    // Matching history collection rules
    match /matchingHistory/{historyId} {
      // Only the customer who performed the matching can read their history
      allow read: if isAuthenticated() && 
                     isOwner(resource.data.customerId);
      
      // Only customers can create matching history
      allow create: if isAuthenticated() && 
                       isCustomer() && 
                       isOwner(resource.data.customerId);
      
      // No updates or deletes (for analytics purposes)
      allow update, delete: if false;
    }
    
    // Auto-tagging history collection rules
    match /autoTaggingHistory/{historyId} {
      // Only the artist owner can read their auto-tagging history
      allow read: if isAuthenticated() && 
                     isOwner(resource.data.artistId);
      
      // System can create auto-tagging history
      allow create: if isAuthenticated() && 
                       isArtist() && 
                       isOwner(resource.data.artistId);
      
      // No updates or deletes (for learning and analytics)
      allow update, delete: if false;
    }
    
    // Geo search history collection rules
    match /geoSearchHistory/{historyId} {
      // Only the user who performed the search can read their history
      allow read: if isAuthenticated() && 
                     isOwner(resource.data.userId);
      
      // Users can create geo search history
      allow create: if isAuthenticated() && 
                       isOwner(resource.data.userId);
      
      // No updates or deletes (for analytics)
      allow update, delete: if false;
    }
    
    // Chat rooms metadata (actual messages are in Realtime Database)
    match /chatRooms/{roomId} {
      // Only participants can read chat room metadata
      allow read: if isAuthenticated() && 
                     (request.auth.uid in resource.data.participants);
      
      // Participants can create chat rooms
      allow create: if isAuthenticated() && 
                       (request.auth.uid in resource.data.participants) &&
                       validateChatRoomData(resource.data);
      
      // Participants can update chat room metadata (e.g., last message info)
      allow update: if isAuthenticated() && 
                       (request.auth.uid in resource.data.participants);
      
      // No deletes (for message history preservation)
      allow delete: if false;
      
      function validateChatRoomData(data) {
        return data.keys().hasAll(['participants', 'createdAt']) &&
               data.participants is list &&
               data.participants.size() == 2 &&
               data.createdAt is timestamp;
      }
    }
    
    // Default deny rule - no access to any other collections
    match /{document=**} {
      allow read, write: if false;
    }
  }
}