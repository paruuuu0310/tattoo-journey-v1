import { useState, useCallback, useEffect } from "react";
import { Alert } from "react-native";
import BookingService, {
  BookingRequest,
  BookingResponse,
} from "../services/BookingService";
import { useNotificationsMock } from "./useNotificationsMock";

type BookingState =
  | "idle"
  | "requested"
  | "pending"
  | "confirmed"
  | "completed"
  | "cancelled";
type ReviewState = "locked" | "unlocked" | "submitted";
type LegalConsentState = "notAgreed" | "agreed";

interface BookingMachineState {
  bookingState: BookingState;
  reviewState: ReviewState;
  legalConsentState: LegalConsentState;
  currentBookingId?: string;
  error?: string;
  isLoading: boolean;
  visitedStudio: boolean;
}

interface LegalConsent {
  version: string;
  timestamp: Date;
  agreementText: string;
}

interface BookingTransitionReason {
  fromState: BookingState;
  toState: BookingState;
  reason: string;
  timestamp: Date;
  bookingId?: string;
}

export interface UseBookingMachine {
  state: BookingMachineState;
  actions: {
    // Booking transitions
    createBookingRequest: (
      customerId: string,
      artistId: string,
      requestData: any,
    ) => Promise<void>;
    acceptBooking: (bookingId: string) => Promise<void>;
    confirmBooking: (
      bookingId: string,
      details: {
        confirmedDate: Date;
        confirmedPrice: number;
        confirmedDuration: number;
      },
    ) => Promise<void>;
    cancelBooking: (bookingId: string, reason: string) => Promise<void>;
    completeBooking: (bookingId: string) => Promise<void>;

    // Review transitions
    markStudioVisited: () => void;
    unlockReview: () => void;
    submitReview: (reviewData: any) => Promise<void>;

    // Legal consent
    agreeLegalTerms: (version: string, agreementText: string) => void;

    // State queries
    canCreateBooking: () => boolean;
    canConfirmBooking: () => boolean;
    canWriteReview: () => boolean;

    // History
    getTransitionHistory: () => BookingTransitionReason[];

    // Reset
    reset: () => void;
  };
  competitorHandling: {
    handleConcurrentBooking: (
      bookingId: string,
      competitorBookingId: string,
    ) => Promise<void>;
    suggestAlternativeSlots: (
      artistId: string,
      originalDate: Date,
    ) => Promise<Date[]>;
  };
}

export const useBookingMachine = (
  initialBookingId?: string,
): UseBookingMachine => {
  const { showNotification } = useNotificationsMock();

  const [state, setState] = useState<BookingMachineState>({
    bookingState: "idle",
    reviewState: "locked",
    legalConsentState: "notAgreed",
    currentBookingId: initialBookingId,
    isLoading: false,
    visitedStudio: false,
  });

  const [transitionHistory, setTransitionHistory] = useState<
    BookingTransitionReason[]
  >([]);
  const [legalConsent, setLegalConsent] = useState<LegalConsent | null>(null);

  // Load saved states on mount
  useEffect(() => {
    const loadSavedStates = async () => {
      try {
        // In real implementation, load from AsyncStorage
        // For now, we'll keep it in memory
      } catch (error) {
        console.error("Failed to load saved booking states:", error);
      }
    };
    loadSavedStates();
  }, []);

  const addTransition = useCallback(
    (
      fromState: BookingState,
      toState: BookingState,
      reason: string,
      bookingId?: string,
    ) => {
      const transition: BookingTransitionReason = {
        fromState,
        toState,
        reason,
        timestamp: new Date(),
        bookingId,
      };

      setTransitionHistory((prev) => [...prev, transition]);
      console.log("üìù Booking State Transition:", transition);
    },
    [],
  );

  const updateBookingState = useCallback(
    (
      newState: BookingState,
      reason: string,
      bookingId?: string,
      additionalUpdates?: Partial<BookingMachineState>,
    ) => {
      setState((prevState) => {
        addTransition(prevState.bookingState, newState, reason, bookingId);

        return {
          ...prevState,
          bookingState: newState,
          currentBookingId: bookingId || prevState.currentBookingId,
          error: undefined,
          ...additionalUpdates,
        };
      });
    },
    [addTransition],
  );

  // Booking State Transitions
  const createBookingRequest = useCallback(
    async (customerId: string, artistId: string, requestData: any) => {
      if (state.bookingState !== "idle") {
        throw new Error(
          `Cannot create booking from state: ${state.bookingState}`,
        );
      }

      setState((prev) => ({ ...prev, isLoading: true }));

      try {
        const bookingId = await BookingService.createBookingRequest(
          customerId,
          artistId,
          requestData,
        );

        updateBookingState("requested", "‰∫àÁ¥Ñ„É™„ÇØ„Ç®„Çπ„Éà„Çí‰ΩúÊàê", bookingId, {
          isLoading: false,
        });

        showNotification({
          type: "success",
          title: "‰∫àÁ¥Ñ„É™„ÇØ„Ç®„Çπ„ÉàÈÄÅ‰ø°ÂÆå‰∫Ü",
          message: "„Ç¢„Éº„ÉÜ„Ç£„Çπ„Éà„Åã„Çâ„ÅÆËøîÁ≠î„Çí„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ",
        });

        // Auto-transition to pending after request is sent
        setTimeout(() => {
          updateBookingState("pending", "‰∫àÁ¥ÑÊâøË™çÂæÖ„Å°Áä∂ÊÖã„Å´ÁßªË°å", bookingId);
        }, 1000);
      } catch (error) {
        setState((prev) => ({
          ...prev,
          isLoading: false,
          error: `‰∫àÁ¥Ñ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ${error}`,
        }));

        showNotification({
          type: "error",
          title: "‰∫àÁ¥Ñ‰ΩúÊàê„Ç®„É©„Éº",
          message: "„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ",
        });

        throw error;
      }
    },
    [state.bookingState, updateBookingState, showNotification],
  );

  const acceptBooking = useCallback(
    async (bookingId: string) => {
      if (state.bookingState !== "pending") {
        throw new Error(
          `Cannot accept booking from state: ${state.bookingState}`,
        );
      }

      setState((prev) => ({ ...prev, isLoading: true }));

      try {
        const response: Omit<
          BookingResponse,
          "id" | "responderId" | "createdAt"
        > = {
          responseType: "accept",
          message: "‰∫àÁ¥Ñ„ÇíÊâøË™ç„Åó„Åæ„Åô„ÄÇË©≥Á¥∞„ÇíÁ¢∫Ë™ç„Åó„Å¶Á¢∫ÂÆö„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ",
        };

        await BookingService.respondToBookingRequest(
          bookingId,
          "artist-id",
          response,
        );

        updateBookingState("confirmed", "‰∫àÁ¥Ñ„ÅåÊâøË™ç„Åï„Çå„Åæ„Åó„Åü", bookingId, {
          isLoading: false,
        });

        showNotification({
          type: "success",
          title: "‰∫àÁ¥ÑÊâøË™ç",
          message: "„Ç¢„Éº„ÉÜ„Ç£„Çπ„Éà„Åå‰∫àÁ¥Ñ„ÇíÊâøË™ç„Åó„Åæ„Åó„Åü",
        });
      } catch (error) {
        setState((prev) => ({
          ...prev,
          isLoading: false,
          error: `‰∫àÁ¥ÑÊâøË™ç„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ${error}`,
        }));

        showNotification({
          type: "error",
          title: "‰∫àÁ¥ÑÊâøË™ç„Ç®„É©„Éº",
          message: "„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ",
        });

        throw error;
      }
    },
    [state.bookingState, updateBookingState, showNotification],
  );

  const confirmBooking = useCallback(
    async (
      bookingId: string,
      details: {
        confirmedDate: Date;
        confirmedPrice: number;
        confirmedDuration: number;
      },
    ) => {
      if (!["pending", "requested"].includes(state.bookingState)) {
        throw new Error(
          `Cannot confirm booking from state: ${state.bookingState}`,
        );
      }

      setState((prev) => ({ ...prev, isLoading: true }));

      try {
        await BookingService.confirmBooking(
          bookingId,
          details.confirmedDate,
          details.confirmedPrice,
          details.confirmedDuration,
        );

        updateBookingState("confirmed", "‰∫àÁ¥Ñ„ÅåÁ¢∫ÂÆö„Åï„Çå„Åæ„Åó„Åü", bookingId, {
          isLoading: false,
        });

        showNotification({
          type: "success",
          title: "‰∫àÁ¥ÑÁ¢∫ÂÆö",
          message: `${details.confirmedDate.toLocaleDateString("ja-JP")} „Å´‰∫àÁ¥Ñ„ÅåÁ¢∫ÂÆö„Åó„Åæ„Åó„Åü`,
        });
      } catch (error) {
        setState((prev) => ({
          ...prev,
          isLoading: false,
          error: `‰∫àÁ¥ÑÁ¢∫ÂÆö„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ${error}`,
        }));

        showNotification({
          type: "error",
          title: "‰∫àÁ¥ÑÁ¢∫ÂÆö„Ç®„É©„Éº",
          message: "„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ",
        });

        throw error;
      }
    },
    [state.bookingState, updateBookingState, showNotification],
  );

  const cancelBooking = useCallback(
    async (bookingId: string, reason: string) => {
      if (!["requested", "pending", "confirmed"].includes(state.bookingState)) {
        throw new Error(
          `Cannot cancel booking from state: ${state.bookingState}`,
        );
      }

      setState((prev) => ({ ...prev, isLoading: true }));

      try {
        await BookingService.cancelBooking(bookingId, "user", reason);

        updateBookingState(
          "cancelled",
          `‰∫àÁ¥Ñ„Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„Åü: ${reason}`,
          bookingId,
          {
            isLoading: false,
          },
        );

        showNotification({
          type: "warning",
          title: "‰∫àÁ¥Ñ„Ç≠„É£„É≥„Çª„É´",
          message: "‰∫àÁ¥Ñ„Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„Åü",
        });
      } catch (error) {
        setState((prev) => ({
          ...prev,
          isLoading: false,
          error: `‰∫àÁ¥Ñ„Ç≠„É£„É≥„Çª„É´„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ${error}`,
        }));

        showNotification({
          type: "error",
          title: "„Ç≠„É£„É≥„Çª„É´„Ç®„É©„Éº",
          message: "„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ",
        });

        throw error;
      }
    },
    [state.bookingState, updateBookingState, showNotification],
  );

  const completeBooking = useCallback(
    async (bookingId: string) => {
      if (state.bookingState !== "confirmed") {
        throw new Error(
          `Cannot complete booking from state: ${state.bookingState}`,
        );
      }

      setState((prev) => ({ ...prev, isLoading: true }));

      try {
        await BookingService.completeBooking(bookingId, "system");

        updateBookingState("completed", "ÊñΩË°ì„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü", bookingId, {
          isLoading: false,
          visitedStudio: true,
        });

        // Unlock review after completion
        setState((prev) => ({
          ...prev,
          reviewState: "unlocked",
        }));

        showNotification({
          type: "success",
          title: "ÊñΩË°ìÂÆå‰∫Ü",
          message: "„ÅäÁñ≤„ÇåÊßò„Åß„Åó„Åü„ÄÇ„É¨„Éì„É•„Éº„ÅÆÊäïÁ®ø„Çí„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô„ÄÇ",
        });
      } catch (error) {
        setState((prev) => ({
          ...prev,
          isLoading: false,
          error: `ÊñΩË°ìÂÆå‰∫ÜÂá¶ÁêÜ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ${error}`,
        }));

        showNotification({
          type: "error",
          title: "ÂÆå‰∫ÜÂá¶ÁêÜ„Ç®„É©„Éº",
          message: "„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ",
        });

        throw error;
      }
    },
    [state.bookingState, updateBookingState, showNotification],
  );

  // Review State Transitions
  const markStudioVisited = useCallback(() => {
    setState((prev) => ({
      ...prev,
      visitedStudio: true,
    }));
    console.log("üè¢ Studio visited flag set to true");
  }, []);

  const unlockReview = useCallback(() => {
    if (!state.visitedStudio) {
      console.warn("Cannot unlock review - studio not visited");
      return;
    }

    setState((prev) => ({
      ...prev,
      reviewState: "unlocked",
    }));

    showNotification({
      type: "info",
      title: "„É¨„Éì„É•„ÉºËß£Êîæ",
      message: "„É¨„Éì„É•„Éº„ÅÆÊäïÁ®ø„ÅåÂèØËÉΩ„Å´„Å™„Çä„Åæ„Åó„Åü",
    });
  }, [state.visitedStudio, showNotification]);

  const submitReview = useCallback(
    async (reviewData: any) => {
      if (state.reviewState !== "unlocked") {
        throw new Error(
          `Cannot submit review from state: ${state.reviewState}`,
        );
      }

      try {
        // Here would be actual review submission logic
        console.log("üìù Submitting review:", reviewData);

        setState((prev) => ({
          ...prev,
          reviewState: "submitted",
        }));

        showNotification({
          type: "success",
          title: "„É¨„Éì„É•„ÉºÊäïÁ®øÂÆå‰∫Ü",
          message: "„É¨„Éì„É•„Éº„Çí„ÅÇ„Çä„Åå„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„Åó„Åü",
        });
      } catch (error) {
        showNotification({
          type: "error",
          title: "„É¨„Éì„É•„ÉºÊäïÁ®ø„Ç®„É©„Éº",
          message: "„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ",
        });
        throw error;
      }
    },
    [state.reviewState, showNotification],
  );

  // Legal Consent
  const agreeLegalTerms = useCallback(
    (version: string, agreementText: string) => {
      const consent: LegalConsent = {
        version,
        timestamp: new Date(),
        agreementText,
      };

      setLegalConsent(consent);
      setState((prev) => ({
        ...prev,
        legalConsentState: "agreed",
      }));

      console.log("‚öñÔ∏è Legal terms agreed:", consent);
    },
    [],
  );

  // State Queries
  const canCreateBooking = useCallback(() => {
    return (
      state.bookingState === "idle" && state.legalConsentState === "agreed"
    );
  }, [state.bookingState, state.legalConsentState]);

  const canConfirmBooking = useCallback(() => {
    return ["pending", "requested"].includes(state.bookingState);
  }, [state.bookingState]);

  const canWriteReview = useCallback(() => {
    return state.reviewState === "unlocked" && state.visitedStudio;
  }, [state.reviewState, state.visitedStudio]);

  // Competitor Handling
  const handleConcurrentBooking = useCallback(
    async (bookingId: string, competitorBookingId: string) => {
      console.log("‚ö° Handling concurrent booking conflict:", {
        bookingId,
        competitorBookingId,
      });

      // Early bird gets the booking
      // Other booking gets alternative suggestions
      try {
        const booking = await BookingService.getUserBookings(
          "user-id",
          "customer",
        );
        const currentBooking = booking.find((b) => b.id === bookingId);

        if (!currentBooking) return;

        const alternatives = await BookingService.findAvailableSlots(
          currentBooking.artistId,
          currentBooking.preferredDate,
          currentBooking.estimatedDuration,
          currentBooking.alternativeDates,
        );

        showNotification({
          type: "warning",
          title: "‰∫àÁ¥ÑÁ´∂ÂêàÁô∫Áîü",
          message: "‰ªñ„ÅÆ‰∫àÁ¥Ñ„Å®Á´∂Âêà„Åó„Åæ„Åó„Åü„ÄÇ‰ª£ÊõøÊ°à„ÇíÊèêÊ°à„Åó„Åæ„Åô„ÄÇ",
        });

        console.log("üîÑ Alternative slots suggested:", alternatives);
      } catch (error) {
        console.error("Error handling concurrent booking:", error);
      }
    },
    [showNotification],
  );

  const suggestAlternativeSlots = useCallback(
    async (artistId: string, originalDate: Date): Promise<Date[]> => {
      try {
        const alternatives = await BookingService.findAvailableSlots(
          artistId,
          originalDate,
          60, // Default 1 hour
          [],
        );

        return alternatives.flatMap((slot) =>
          slot.slots.map((s) => s.startTime),
        );
      } catch (error) {
        console.error("Error suggesting alternative slots:", error);
        return [];
      }
    },
    [],
  );

  const getTransitionHistory = useCallback(() => {
    return transitionHistory;
  }, [transitionHistory]);

  const reset = useCallback(() => {
    setState({
      bookingState: "idle",
      reviewState: "locked",
      legalConsentState: "notAgreed",
      isLoading: false,
      visitedStudio: false,
    });
    setTransitionHistory([]);
    setLegalConsent(null);
  }, []);

  return {
    state,
    actions: {
      createBookingRequest,
      acceptBooking,
      confirmBooking,
      cancelBooking,
      completeBooking,
      markStudioVisited,
      unlockReview,
      submitReview,
      agreeLegalTerms,
      canCreateBooking,
      canConfirmBooking,
      canWriteReview,
      getTransitionHistory,
      reset,
    },
    competitorHandling: {
      handleConcurrentBooking,
      suggestAlternativeSlots,
    },
  };
};
